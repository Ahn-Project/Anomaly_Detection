# -*- coding: utf-8 -*-
"""train (similarity_based)_with real.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1La4YIl7xThrTnKYfiStsXkiDYJ5_fdFp
"""

# from __future__ import print_function, division
from model import resnet
import torch
import torch.nn as nn
import torch.optim as optim
from torch.optim import lr_scheduler
import numpy as np
import pandas as pd
import torchvision
from torchvision import datasets, models, transforms
import matplotlib.pyplot as plt
import os
import copy


##########################################################
def data_load(root_dir):
    # abnormal image 데이터 로드
    data_transforms = transforms.Compose([
        transforms.Resize(224),
        transforms.ToTensor(),
        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
    ])

    dataset = datasets.ImageFolder(root_dir,
                                   transform=data_transforms)

    testloader = torch.utils.data.DataLoader(dataset,
                                             batch_size=4,
                                             shuffle=False)
    return dataset, testloader


def load_model(wts_name, n_classes):
    weights_path = './weights/' + wts_name
    model = resnet.resnet18(pretrained=False)
    num_ftrs = model.fc.in_features
    model.fc = nn.Linear(num_ftrs, n_classes)
    model.load_state_dict(torch.load(weights_path))
    return model


def test(model, testLoader):
    correct = 0
    total = 0
    device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
    model = model.to(device)

    fvs, label_epoch = [], []  # 추가 부분
    with torch.no_grad():
        for i, data in enumerate(testLoader):
            inputs, labels = data[0].to(device), data[1].to(device)
            outputs, fv = model(inputs)
            _, predicted = torch.max(outputs.data, 1)
            fvs.extend(fv)  # 추가 부분
            label_epoch.extend(labels)  # 추가 부분
            # pred_argmax = torch.argmax(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

            print('iter:{}  accuarcy:{}'.format(i, (correct / total)))

    accuracy = (correct / total)
    print('Accuracy: {}'.format(accuracy))

    return accuracy, fvs, label_epoch, predicted


##########################################################
### weight Downloading: "https://download.pytorch.org/models/resnet18-5c106cde.pth" to C:\Users\neouly08/.cache\torch\hub\checkpoints\resnet18-5c106cde.pth


if __name__ == "__main__":
    version = 1
    num_epochs = 5
    n_classes = 4

    root_dirs = ['./data/query_img/']
    file_names = ['query']
    for i, root_dir, file_name in zip(range(1), root_dirs, file_names):
        dataset, testloader = data_load(root_dir)

        dataset_sizes = len(dataset)
        class_names = dataset.classes
        device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')

        ################
        # load model
        wts_name = 'weights_both_ver{} (epochs={}).pth'.format(version, num_epochs)
        model = load_model(wts_name, n_classes)
        model.eval()

        if torch.cuda.is_available():
            model.cuda()

        # test
        accuracy, fvs, label_epoch, predicted = test(model, testloader)

        ################
        # fvs 저장
        fvs_list = list(map(lambda x: fvs[x].tolist(), range(len(fvs))))  # 추가 부분
        label_item = list(map(lambda x: label_epoch[x].item(), range(len(label_epoch))))  # 추가 부분

        fvs_array = np.array(fvs_list[:])
        label_array = np.array(label_item[:])

        fvs_save_path = './fvs/'
        dir_path = fvs_save_path + 'fvs_both_ver{}'.format(version)
        if not os.path.isdir(dir_path):
            os.mkdir(dir_path)

        np.save(os.path.join(dir_path, 'fvs_{}_ver{}'.format(file_name, version)), fvs_array)
        if i == 0:
            np.save(os.path.join(dir_path, 'label_{}_ver{}'.format(file_name, version)), predicted.cpu().numpy())
        else:
            np.save(os.path.join(dir_path, 'label_{}_ver{}'.format(file_name, version)), label_array)

        ################
        # if i == 0:
        #     # label
        #     class_names_df = pd.DataFrame(class_names, columns=['label'])
        #     x = pd.read_csv(os.path.join(dir_path, 'class_names.csv'))
        #     x2 = pd.concat([x, class_names_df])
        #     x2.to_csv(os.path.join(dir_path, 'class_names.csv'), index=False)




