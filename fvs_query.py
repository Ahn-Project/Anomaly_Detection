# -*- coding: utf-8 -*-
"""train (similarity_based)_with real.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1La4YIl7xThrTnKYfiStsXkiDYJ5_fdFp
"""

# from __future__ import print_function, division
from model import resnet
import torch
import torch.nn as nn
import numpy as np
import pandas as pd
from torchvision import datasets, models, transforms
import os
import argparse


##########################################################
def load_data(root_dir):
    data_transforms = transforms.Compose([
        transforms.Resize(224),
        transforms.ToTensor(),
        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
    ])

    dataset = datasets.ImageFolder(root_dir,
                                   transform=data_transforms)

    testloader = torch.utils.data.DataLoader(dataset,
                                             batch_size=4,
                                             shuffle=False)
    return dataset, testloader


def load_model(wts_name, n_classes):
    weights_path = './weights/' + wts_name
    model = resnet.resnet18(pretrained=False)
    num_ftrs = model.fc.in_features
    model.fc = nn.Linear(num_ftrs, n_classes)
    model.load_state_dict(torch.load(weights_path))
    return model


def test(model, testLoader):
    correct = 0
    total = 0
    device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
    model = model.to(device)

    fvs, label_epoch = [], []  # 추가 부분
    with torch.no_grad():
        for i, data in enumerate(testLoader):
            inputs, labels = data[0].to(device), data[1].to(device)
            outputs, fv = model(inputs)
            _, predicted = torch.max(outputs.data, 1)
            fvs.extend(fv)  # 추가 부분
            label_epoch.extend(labels)  # 추가 부분
            # pred_argmax = torch.argmax(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()

            print('iter:{}  accuarcy:{}'.format(i, (correct / total)))

    accuracy = (correct / total)
    print('Accuracy: {}'.format(accuracy))

    return accuracy, fvs, label_epoch, predicted


##########################################################
### weight Downloading: "https://download.pytorch.org/models/resnet18-5c106cde.pth" to C:\Users\neouly08/.cache\torch\hub\checkpoints\resnet18-5c106cde.pth


if __name__ == "__main__":
    version = 1  # 조정 부분
    num_epochs = 5  # 조정 부분

    # parser 생성
    parser = argparse.ArgumentParser()

    # 인자 조건 추가
    parser.add_argument('--data', type=str, default='both',
                        choices=['both', 'normal'],
                        help='what is the data needed in your task?')

    # parsing 후 저장
    args = parser.parse_args()
    arg_data = args.data

    # 데이터 로드
    root_dir = './data/query_img/'
    dataset, testloader = load_data(root_dir)

    dataset_sizes = len(dataset)
    class_names = dataset.classes
    device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')

    ################
    # load model
    if arg_data == 'both':
        n_classes = 4
    else:
        n_classes = 2
    wts_name = 'weights_{}_ver{} (epochs={}).pth'.format(arg_data, version, num_epochs)
    model = load_model(wts_name, n_classes)
    model.eval()

    if torch.cuda.is_available():
        model.cuda()

    # test
    accuracy, fvs, label_epoch, predicted = test(model, testloader)

    ################
    # fvs 저장
    fvs_list = list(map(lambda x: fvs[x].tolist(), range(len(fvs))))  # 추가 부분
    label_item = list(map(lambda x: label_epoch[x].item(), range(len(label_epoch))))  # 추가 부분

    fvs_array = np.array(fvs_list[:])
    label_array = np.array(label_item[:])

    fvs_save_path = './fvs/'
    dir_path = fvs_save_path + 'fvs_{}_ver{}'.format(arg_data, version)
    if not os.path.isdir(dir_path):
        os.mkdir(dir_path)

    file_name = 'query'
    np.save(os.path.join(dir_path, 'fvs_{}_ver{}'.format(file_name, version)), fvs_array)
    np.save(os.path.join(dir_path, 'label_{}_ver{}'.format(file_name, version)), predicted.cpu().numpy())




